{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = void 0;\nvar isArrayLike_1 = require(\"../util/isArrayLike\");\nvar isPromise_1 = require(\"../util/isPromise\");\nvar Observable_1 = require(\"../Observable\");\nvar isInteropObservable_1 = require(\"../util/isInteropObservable\");\nvar isAsyncIterable_1 = require(\"../util/isAsyncIterable\");\nvar throwUnobservableError_1 = require(\"../util/throwUnobservableError\");\nvar isIterable_1 = require(\"../util/isIterable\");\nvar isReadableStreamLike_1 = require(\"../util/isReadableStreamLike\");\nvar isFunction_1 = require(\"../util/isFunction\");\nvar reportUnhandledError_1 = require(\"../util/reportUnhandledError\");\nvar observable_1 = require(\"../symbol/observable\");\nfunction innerFrom(input) {\n  if (input instanceof Observable_1.Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable_1.isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike_1.isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise_1.isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable_1.isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable_1.isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike_1.isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n  throw throwUnobservableError_1.createInvalidObservableTypeError(input);\n}\nexports.innerFrom = innerFrom;\nfunction fromInteropObservable(obj) {\n  return new Observable_1.Observable(function (subscriber) {\n    var obs = obj[observable_1.observable]();\n    if (isFunction_1.isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\nexports.fromInteropObservable = fromInteropObservable;\nfunction fromArrayLike(array) {\n  return new Observable_1.Observable(function (subscriber) {\n    for (var i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\nexports.fromArrayLike = fromArrayLike;\nfunction fromPromise(promise) {\n  return new Observable_1.Observable(function (subscriber) {\n    promise.then(function (value) {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    }, function (err) {\n      return subscriber.error(err);\n    }).then(null, reportUnhandledError_1.reportUnhandledError);\n  });\n}\nexports.fromPromise = fromPromise;\nfunction fromIterable(iterable) {\n  return new Observable_1.Observable(function (subscriber) {\n    var e_1, _a;\n    try {\n      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {\n        var value = iterable_1_1.value;\n        subscriber.next(value);\n        if (subscriber.closed) {\n          return;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    subscriber.complete();\n  });\n}\nexports.fromIterable = fromIterable;\nfunction fromAsyncIterable(asyncIterable) {\n  return new Observable_1.Observable(function (subscriber) {\n    process(asyncIterable, subscriber).catch(function (err) {\n      return subscriber.error(err);\n    });\n  });\n}\nexports.fromAsyncIterable = fromAsyncIterable;\nfunction fromReadableStreamLike(readableStream) {\n  return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));\n}\nexports.fromReadableStreamLike = fromReadableStreamLike;\nfunction process(asyncIterable, subscriber) {\n  var asyncIterable_1, asyncIterable_1_1;\n  var e_2, _a;\n  return __awaiter(this, void 0, void 0, function () {\n    var value, e_2_1;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _b.trys.push([0, 5, 6, 11]);\n          asyncIterable_1 = __asyncValues(asyncIterable);\n          _b.label = 1;\n        case 1:\n          return [4, asyncIterable_1.next()];\n        case 2:\n          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];\n          value = asyncIterable_1_1.value;\n          subscriber.next(value);\n          if (subscriber.closed) {\n            return [2];\n          }\n          _b.label = 3;\n        case 3:\n          return [3, 1];\n        case 4:\n          return [3, 11];\n        case 5:\n          e_2_1 = _b.sent();\n          e_2 = {\n            error: e_2_1\n          };\n          return [3, 11];\n        case 6:\n          _b.trys.push([6,, 9, 10]);\n          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];\n          return [4, _a.call(asyncIterable_1)];\n        case 7:\n          _b.sent();\n          _b.label = 8;\n        case 8:\n          return [3, 10];\n        case 9:\n          if (e_2) throw e_2.error;\n          return [7];\n        case 10:\n          return [7];\n        case 11:\n          subscriber.complete();\n          return [2];\n      }\n    });\n  });\n}","map":{"version":3,"names":["isArrayLike_1","require","isPromise_1","Observable_1","isInteropObservable_1","isAsyncIterable_1","throwUnobservableError_1","isIterable_1","isReadableStreamLike_1","isFunction_1","reportUnhandledError_1","observable_1","innerFrom","input","Observable","isInteropObservable","fromInteropObservable","isArrayLike","fromArrayLike","isPromise","fromPromise","isAsyncIterable","fromAsyncIterable","isIterable","fromIterable","isReadableStreamLike","fromReadableStreamLike","createInvalidObservableTypeError","exports","obj","subscriber","obs","observable","isFunction","subscribe","TypeError","array","i","length","closed","next","complete","promise","then","value","err","error","reportUnhandledError","iterable","iterable_1","__values","iterable_1_1","done","asyncIterable","process","catch","readableStream","readableStreamLikeToAsyncGenerator","asyncIterable_1","__asyncValues","asyncIterable_1_1"],"sources":["/Users/anil/Documents/GitHub/1appAI/node_modules/rxjs/src/internal/observable/innerFrom.ts"],"sourcesContent":["import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}