{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.single = void 0;\nvar EmptyError_1 = require(\"../util/EmptyError\");\nvar SequenceError_1 = require(\"../util/SequenceError\");\nvar NotFoundError_1 = require(\"../util/NotFoundError\");\nvar lift_1 = require(\"../util/lift\");\nvar OperatorSubscriber_1 = require(\"./OperatorSubscriber\");\nfunction single(predicate) {\n  return lift_1.operate(function (source, subscriber) {\n    var hasValue = false;\n    var singleValue;\n    var seenValue = false;\n    var index = 0;\n    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n      seenValue = true;\n      if (!predicate || predicate(value, index++, source)) {\n        hasValue && subscriber.error(new SequenceError_1.SequenceError('Too many matching values'));\n        hasValue = true;\n        singleValue = value;\n      }\n    }, function () {\n      if (hasValue) {\n        subscriber.next(singleValue);\n        subscriber.complete();\n      } else {\n        subscriber.error(seenValue ? new NotFoundError_1.NotFoundError('No matching values') : new EmptyError_1.EmptyError());\n      }\n    }));\n  });\n}\nexports.single = single;","map":{"version":3,"names":["EmptyError_1","require","SequenceError_1","NotFoundError_1","lift_1","OperatorSubscriber_1","single","predicate","operate","source","subscriber","hasValue","singleValue","seenValue","index","subscribe","createOperatorSubscriber","value","error","SequenceError","next","complete","NotFoundError","EmptyError","exports"],"sources":["/Users/anil/Documents/GitHub/armada-ai/node_modules/rxjs/src/internal/operators/single.ts"],"sourcesContent":["import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\n\nimport { MonoTypeOperatorFunction, OperatorFunction, TruthyTypesOf } from '../types';\nimport { SequenceError } from '../util/SequenceError';\nimport { NotFoundError } from '../util/NotFoundError';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function single<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that asserts that only one value is\n * emitted from the observable that matches the predicate. If no\n * predicate is provided, then it will assert that the observable\n * only emits one value.\n *\n * In the event that the observable is empty, it will throw an\n * {@link EmptyError}.\n *\n * In the event that two values are found that match the predicate,\n * or when there are two values emitted and no predicate, it will\n * throw a {@link SequenceError}\n *\n * In the event that no values match the predicate, if one is provided,\n * it will throw a {@link NotFoundError}\n *\n * ## Example\n *\n * Expect only `name` beginning with `'B'`\n *\n * ```ts\n * import { of, single } from 'rxjs';\n *\n * const source1 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Laney' },\n *  { name: 'Lily' }\n * );\n *\n * source1\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe(x => console.log(x));\n * // Emits 'Ben'\n *\n *\n * const source2 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Bradley' },\n *  { name: 'Lincoln' }\n * );\n *\n * source2\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: SequenceError('Too many values match')\n *\n *\n * const source3 = of(\n *  { name: 'Laney' },\n *  { name: 'Tracy' },\n *  { name: 'Lily' },\n *  { name: 'Lincoln' }\n * );\n *\n * source3\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: NotFoundError('No values match')\n * ```\n *\n * @see {@link first}\n * @see {@link find}\n * @see {@link findIndex}\n * @see {@link elementAt}\n *\n * @throws {NotFoundError} Delivers an NotFoundError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @throws {SequenceError} Delivers a SequenceError if more than one value is emitted that matches the\n * provided predicate. If no predicate is provided, will deliver a SequenceError if more\n * than one value comes from the source\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return A function that returns an Observable that emits the single item\n * emitted by the source Observable that matches the predicate.\n */\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let singleValue: T;\n    let seenValue = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          seenValue = true;\n          if (!predicate || predicate(value, index++, source)) {\n            hasValue && subscriber.error(new SequenceError('Too many matching values'));\n            hasValue = true;\n            singleValue = value;\n          }\n        },\n        () => {\n          if (hasValue) {\n            subscriber.next(singleValue);\n            subscriber.complete();\n          } else {\n            subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());\n          }\n        }\n      )\n    );\n  });\n}\n"],"mappings":";;;;;;AACA,IAAAA,YAAA,GAAAC,OAAA;AAGA,IAAAC,eAAA,GAAAD,OAAA;AACA,IAAAE,eAAA,GAAAF,OAAA;AACA,IAAAG,MAAA,GAAAH,OAAA;AACA,IAAAI,oBAAA,GAAAJ,OAAA;AAiFA,SAAgBK,MAAMA,CAAIC,SAAuE;EAC/F,OAAOH,MAAA,CAAAI,OAAO,CAAC,UAACC,MAAM,EAAEC,UAAU;IAChC,IAAIC,QAAQ,GAAG,KAAK;IACpB,IAAIC,WAAc;IAClB,IAAIC,SAAS,GAAG,KAAK;IACrB,IAAIC,KAAK,GAAG,CAAC;IACbL,MAAM,CAACM,SAAS,CACdV,oBAAA,CAAAW,wBAAwB,CACtBN,UAAU,EACV,UAACO,KAAK;MACJJ,SAAS,GAAG,IAAI;MAChB,IAAI,CAACN,SAAS,IAAIA,SAAS,CAACU,KAAK,EAAEH,KAAK,EAAE,EAAEL,MAAM,CAAC,EAAE;QACnDE,QAAQ,IAAID,UAAU,CAACQ,KAAK,CAAC,IAAIhB,eAAA,CAAAiB,aAAa,CAAC,0BAA0B,CAAC,CAAC;QAC3ER,QAAQ,GAAG,IAAI;QACfC,WAAW,GAAGK,KAAK;;IAEvB,CAAC,EACD;MACE,IAAIN,QAAQ,EAAE;QACZD,UAAU,CAACU,IAAI,CAACR,WAAW,CAAC;QAC5BF,UAAU,CAACW,QAAQ,EAAE;OACtB,MAAM;QACLX,UAAU,CAACQ,KAAK,CAACL,SAAS,GAAG,IAAIV,eAAA,CAAAmB,aAAa,CAAC,oBAAoB,CAAC,GAAG,IAAItB,YAAA,CAAAuB,UAAU,EAAE,CAAC;;IAE5F,CAAC,CACF,CACF;EACH,CAAC,CAAC;AACJ;AA5BAC,OAAA,CAAAlB,MAAA,GAAAA,MAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}