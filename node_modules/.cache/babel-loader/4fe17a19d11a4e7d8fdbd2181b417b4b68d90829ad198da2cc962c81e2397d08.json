{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.takeLast = void 0;\nvar empty_1 = require(\"../observable/empty\");\nvar lift_1 = require(\"../util/lift\");\nvar OperatorSubscriber_1 = require(\"./OperatorSubscriber\");\nfunction takeLast(count) {\n  return count <= 0 ? function () {\n    return empty_1.EMPTY;\n  } : lift_1.operate(function (source, subscriber) {\n    var buffer = [];\n    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n      buffer.push(value);\n      count < buffer.length && buffer.shift();\n    }, function () {\n      var e_1, _a;\n      try {\n        for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {\n          var value = buffer_1_1.value;\n          subscriber.next(value);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      subscriber.complete();\n    }, undefined, function () {\n      buffer = null;\n    }));\n  });\n}\nexports.takeLast = takeLast;","map":{"version":3,"names":["empty_1","require","lift_1","OperatorSubscriber_1","takeLast","count","EMPTY","operate","source","subscriber","buffer","subscribe","createOperatorSubscriber","value","push","length","shift","buffer_1","__values","buffer_1_1","next","done","complete","undefined","exports"],"sources":["/Users/anil/Documents/GitHub/armada-ai/node_modules/rxjs/src/internal/operators/takeLast.ts"],"sourcesContent":["import { EMPTY } from '../observable/empty';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Waits for the source to complete, then emits the last N values from the source,\n * as specified by the `count` argument.\n *\n * ![](takeLast.png)\n *\n * `takeLast` results in an observable that will hold values up to `count` values in memory,\n * until the source completes. It then pushes all values in memory to the consumer, in the\n * order they were received from the source, then notifies the consumer that it is\n * complete.\n *\n * If for some reason the source completes before the `count` supplied to `takeLast` is reached,\n * all values received until that point are emitted, and then completion is notified.\n *\n * **Warning**: Using `takeLast` with an observable that never completes will result\n * in an observable that never emits a value.\n *\n * ## Example\n *\n * Take the last 3 values of an Observable with many values\n *\n * ```ts\n * import { range, takeLast } from 'rxjs';\n *\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return A function that returns an Observable that emits at most the last\n * `count` values emitted by the source Observable.\n */\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        // This buffer will hold the values we are going to emit\n        // when the source completes. Since we only want to take the\n        // last N values, we can't emit until we're sure we're not getting\n        // any more values.\n        let buffer: T[] = [];\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              // Add the most recent value onto the end of our buffer.\n              buffer.push(value);\n              // If our buffer is now larger than the number of values we\n              // want to take, we remove the oldest value from the buffer.\n              count < buffer.length && buffer.shift();\n            },\n            () => {\n              // The source completed, we now know what are last values\n              // are, emit them in the order they were received.\n              for (const value of buffer) {\n                subscriber.next(value);\n              }\n              subscriber.complete();\n            },\n            // Errors are passed through to the consumer\n            undefined,\n            () => {\n              // During finalization release the values in our buffer.\n              buffer = null!;\n            }\n          )\n        );\n      });\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AAEA,IAAAC,MAAA,GAAAD,OAAA;AACA,IAAAE,oBAAA,GAAAF,OAAA;AAyCA,SAAgBG,QAAQA,CAAIC,KAAa;EACvC,OAAOA,KAAK,IAAI,CAAC,GACb;IAAM,OAAAL,OAAA,CAAAM,KAAK;EAAL,CAAK,GACXJ,MAAA,CAAAK,OAAO,CAAC,UAACC,MAAM,EAAEC,UAAU;IAKzB,IAAIC,MAAM,GAAQ,EAAE;IACpBF,MAAM,CAACG,SAAS,CACdR,oBAAA,CAAAS,wBAAwB,CACtBH,UAAU,EACV,UAACI,KAAK;MAEJH,MAAM,CAACI,IAAI,CAACD,KAAK,CAAC;MAGlBR,KAAK,GAAGK,MAAM,CAACK,MAAM,IAAIL,MAAM,CAACM,KAAK,EAAE;IACzC,CAAC,EACD;;;QAGE,KAAoB,IAAAC,QAAA,GAAAC,QAAA,CAAAR,MAAM,GAAAS,UAAA,GAAAF,QAAA,CAAAG,IAAA,KAAAD,UAAA,CAAAE,IAAA,EAAAF,UAAA,GAAAF,QAAA,CAAAG,IAAA,IAAE;UAAvB,IAAMP,KAAK,GAAAM,UAAA,CAAAN,KAAA;UACdJ,UAAU,CAACW,IAAI,CAACP,KAAK,CAAC;;;;;;;;;;;;;MAExBJ,UAAU,CAACa,QAAQ,EAAE;IACvB,CAAC,EAEDC,SAAS,EACT;MAEEb,MAAM,GAAG,IAAK;IAChB,CAAC,CACF,CACF;EACH,CAAC,CAAC;AACR;AApCAc,OAAA,CAAApB,QAAA,GAAAA,QAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}